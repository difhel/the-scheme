# Генераторы в BS
Генераторы - это выражения, которые вычисляются в compile time, принимают какое-то выражение и возвращают новый тип.

Генераторы используются для реализации механизма dependant types - зависимых типов.

## Список генераторов
### `next`
Генератор `next` принимает натуральное число (обозначается как параметр с типом `#`) и возвращает тип со значением на единицу больше, чем переданное.

```
next: # -> #
```

Пример использования:
```
tnil = Tuple[0];
tcons [n: #] head: int, tail: Tuple[n] = Tuple[next(n)];
```

В этом примере мы рекурсивно определяем тип `Tuple` - коллекцию `int` с заданной размерностью.
В первом конструкторе мы определяем `Tuple[0]` - пустую коллекцию.
Во втором конструкторе указывается переменная `n`, которая действует как nat-ограничение (`[n: #]`). Далее идет первый элемент коллекции (`head: int`). После этого идет остаток коллекции (`tail`) - коллекция с размерностью `n`. Второй конструктор определяет тип `Tuple` для размерности `next(n)`, то есть `n + 1`.

С помощью кода выше можно легко определить, например, тройку чисел:
```
triple value: Tuple[3] = Triple;
```

При передаче данных типа `Triple` при десериализации произойдет чтение параметра `value`, который определен как `Tuple[3]`. Десериализация типа `Tuple[3]` произойдет рекурсивно в runtime - сначала будет считано одно число, а далее запускается десериализация значения типа `Tuple[2]`; затем считывается еще одно число и запускается десериализация значения типа `Tuple[1]`; затем считывается одно число и запускается десериализация значения типа `Tuple[0]`; на этом чтение заканчивается, потому что `Tuple[0]` не имеет параметров (см. конструктор `tnil`).

### `limit`
Генератор `limit` служит для оптимизации передачи целых чисел.

Будет проще разобрать на примере:
```
register name: string, region_code: int = null;
registerNew name: string, region_code: limit(1 to 100) = null;
```

В первом случае на передачу поля `region_code` будет потрачено 4 байта (именно столько занимает тип int). Однако это можно оптимизировать, если знать, в каком пределе может находиться значение параметра.

Во втором примере вместо указания конкретного целочисленного типа мы указываем предел - специальный тип, который принимает выражение вида `# to #`. Limit использует минимальное количество бит, которое гарантирует, что все значения в пределе могут быть записаны.

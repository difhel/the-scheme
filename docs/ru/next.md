# Документация BS

> **Внимание!**
> Вы смотрите документацию к НЕСТАБИЛЬНОЙ ВЕРСИИ Layer Next.

# Устройство базовых типов
## Числовые типы
- `bool` - (0 - false, 1 - true). Занимает 1 бит. Все bool-значения передаются ранее всех остальных значений подряд.
- `char` или `int8` - 8-битное число
- `short` или `int16` - 16-битное число
- `int` или `int32` - 32-битное целое число
- `int64` - 64-битное целое число
- `int128` - 128-битное специальное число
- `float` - 32-битное число с плавающей точкой (одинарной точности)
- `double` - 64-битное число с плавающей точкой (двойной точности)

Целочисленные типы (`int8`, `int16`, `int32`, `int64`, `int128`) передаются в виде [дополнительного кода](https://en.wikipedia.org/wiki/Two%27s_complement) до 2.

Типы чисел с плавающей точкой передаются в виде экспоненциальной записи по спецификации [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754).

## Специальные типы
- `null`. Кодируется специальным образом:
    - если тип параметра или возвращаемого значения кобминатора не может быть `null` (например, `int` или `int | vector<int>`), `null` не влияет на схему кодирования.
    - если тип параметра или возвращаемого значения может быть `null`, перед всеми остальными параметрами передаются флаги nullable-типов.

Рассмотрим допустимые значения, которые возвращает следующий метод:
```
users.getUserById id: int = User | null;
```
- `0 <alignment>` - метод вернул `null`
- `1 ...` - метод вернул не `null`, далее идет описание объекта типа `User`.

## Контейнерные типы
- `vector<T>` - вектор элементов типа `T`
- `string` - `vector<char>`

### vector<T>
В начале передается `int length` - длина вектора. Далее парсер считывает `length` раз объект типа `T`.

# Десериализация и сериализация
Формат, в котором передается весь запрос от одной стороне другой выглядит в общем виде так:

```
<4 байта на CRC32 хеш конструктора типа или метода> <bool-параметры> <флаги nullable-параметров> <value1> <value2> ... <alignment>
```
Разберем, что означает каждый из элементов.
- **CRC32 хеш конструктора.** Хеш конструктора типа или метода, по которому парсер узнает, в каком формате представлены дальнейшие данные.
- **Bool-параметры.** Если в комбинаторе есть $n$ bool-параметров (например, `test a: int, b: bool, c: string, d: bool = Test;`), в следующих $n$ битах будут указаны значения этих параметров (например, при $a=179$, $b=true$, $c="hello"$ и $d=false$) в bool-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Вместе с остальными параметрами они повторно не передаются.
- **Флаги nullable-параметров.** Если в комбинаторе есть $n$ nullable-параметров (например, `test a: int | null, b: int, c: string | null, d: bool = Test;`), в следующих $n$ битах будет указано, имеет ли $i$-ый параметр значение null (например, при $a=null$, $b=42$, $c="hello"$ и $d=false$) в nullable-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Параметры, значения которых равны null, вместе с остальными параметрами повторно не передаются, а параметры, не являющиеся null, передаются в обычном порядке (например, если был параметр $test = T | null$, и в флагах указано, что он не null, парсеру потребуется считать значение типа $T$).
- **`<alignment>`.** Дополнение последнего байта в запросе неустановленными битами, чтобы размер запроса занимал целочисленное количество байт.

**В случае ответа на запрос, схема точно такая же, но хеш не передается**. Это попросту ненужно: хеш вызываемого метода известен клиенту, так как ему известно, ответом на какой запрос данный ответ является. Тип ответа тоже не указывается, так как он известен на этапе десериализации.

---

Рассмотрим такой пример:
```
---types---
user id: int, user: User = ChatMember;
bot id: int, bot: Bot = ChatMember;

---methods---
messages.getChatMembers chat_id: int = vector<ChatMember> | null;
```

Представим, что метод возвращает участников чата по его идентификатору или `null`, если чата с таким `id` не существует. Также есть тип `ChatMember` с 2 конструкторами - для пользователя (человека) и бота (будем считать, что `User` и `Bot` - 2 разных типа).

Рассмотрим варианты ответа сервера на такой запрос:
- Чата не существует. Метод должен вернуть `null`. Как написано в описании типа `null`, будет возвращен такой результат из одного байта: `10000000` (1 бит будет установленным, так как первый nullable-параметр является `null`, а остальные 7 битов будут нулями из-за выравнивания).
- Чат существует. В начале ответа сервер вернет данные о том, что ответ не `null`, и нужно дальше его парсить: `0`. Так как, помимо `null`, метод может вернуть только один тип (`vector<ChatMember>`), не нужно указывать его хеш, поскольку парсер уже знает, какой тип ожидается и может сразу начать читать вектор объектов типа `ChatMember`. Для начала должна быть прочитана длина этого вектора: `0x2` - означает, что вектор содержит 2 элемента. Дальше нужно 2 раза прочитать `ChatMember`, но у него есть 2 конструктора. Чтобы понять, какой именно из них нужно вызывать при десериализации, должен быть указан хеш от сигнатуры конструктора, по которому определяется нужный комбинатор и конструируется тип. В отличие от случая выше, когда было заранее известно, что тип - не `null`, а определяется однозначно как `vector<ChatMember>`, здесь неясно, какой из 2 типов (`ChatMember.user` или `ChatMember.bot`) должен вызываться. В качестве хеша конструктора используется CRC32 от нормализованной строки с описанием комбинатора:
```
CRC32("user id: int, user: User = ChatMember") = 0x15993ea9
CRC32("bot id: int, bot: Bot = ChatMember") = 0x69b35687
```
Для примера представим, что весь результат выполнения функции выглядит так (в виде JSON):
```json
[
    {
        "_": "ChatMember.user",
        "id": 1,
        "user": {
            "_": "User", // дальше поля, описывающие тип User
        }
    },
    {
        "_": "ChatMember.bot",
        "id": 2,
        "bot": {
            "_": "Bot", // дальше поля, описывающие тип Bot
        }
    }
]
```

В серилиазованном виде этот результат будет выглядеть примерно так:
```
0 0x2 0x15993ea9 0x1 <тип User> 0x69b35687 0x2 <тип Bot>
```

После рассмотрения примера опишем принципы сериализации/десериализации более строго.
- Если тип bool, то соответствующий бит в флаге принимает значение параметра. Далее значение этого параметра пропускается при обработке параметров.
- Если тип nullable и равен null, то соответствующий бит в флаге устанавливается, а значение параметра пропускается при обработке параметров.
- Если тип nullable и не равен null, то соответствующий бит в флаге не устанавливается, а значение параметра передается вместе с остальными параметрами.
- Для fully-defined типа не указывается хеш конструктора, поскольку fully-defined тип содержит данные о том, какой конструктор используется в данном случае.
- Для only-typename типа, который имеет ровно один конструктор, хеш конструктора не указывается.
- Для only-typename типа, который имеет несколько конструкторов, указывается хеш конструктора.
- Для опционального типа (`type_1 | type_2 | type_3`) перед указанием значения параметра должен быть указан CRC32-хеш сигнатуры конструктора типа, объект которого указывается далее.

# Формат схемы
## Типы
### Простейший обзор
Типы используются в параметрах функции или другого типа, а также в возвращаемом значении функции. Они могут быть описаны двумя способами:
1. **Only type name.** Например, `User`. Если у типа есть только один конструктор, он и будет использоваться при работе с данными, иначе потребуется указать CRC32 хеш конструктора, который используется в данном случае.
2. **Fully-defined type.** Например, `User.bot`. В такой записи указывается сам тип и вызываемый конструктор, что позволяет однозначно установить, в каком формате будут передаваться данные, из-за чего указывать хеш конструктора не нужно.

В общем виде тип выглядит так:
```
(<namespace>::)? <type name> (.<constructor name>)>? <generics>? <dimensionality>?
```

Здесь:
- **`namespace`** - опциональная часть - у типа может быть свое пространство имен для избежания конфликтов (например, вы пишите сервис, который взаимодействует с сторонним API; и у вашего API, и у стороннего есть тип `User` - в таком случае для удобства можно разделить типы на namespaces - например, `internal::User` и `external::User`). Вы также можете использовать вложенные пространства имен, разделяя названия точками - например, `external.telegram::User`. `::` отделяет название пространства имен и название имени типа.
- **`<type name>`** - обязательная часть - название типа. По очевидным причинам не может содержать точки.
-  **`<constructor name>`** - опциональная часть - четкое указание конструктора (для fully-defined типов).
- **`<generics>`** - опциональная часть - в угловых скобках перечислены типы, от которых зависит данный тип, см. [Полиморфные (generic) типы](./next.md#полиморфные-generic-типы).
- **`<dimensionality>`** - опциональная часть - в квадратных скобках перечислены переменные, от которых зависит данный тип, см. [Зависимые типы](./next.md#зависимые-типы).

Еще немного дополнительных фактов про пространства имен:
- все встроенные типы находятся в пространстве имен под названием `std`, из-за чего `std::int` и `int` - это одно и то же. Это сделано для удобства, не стоит использовать префикс `std::` перед указанием встроенного типа.
- все определяемые программистом типы помещаются в пространство `default`, из-за чего `default::User` и `User` - это одно и то же. Это сделано для удобства, не стоит использовать префикс `default::` перед указанием кастомного типа без указанного пространства имен.

### Полиморфные (generic) типы
Полиморфные типы - это типы, которые зависят от переданных *типов*. Пример: `vector<int>`.

Тип может зависеть от нескольких типов. Примеры:
```
constructor {T, K, S} value1: T, value2: K, value3: S = GenericType<T, K, S>;
```

Как видно из примера выше, переменные, обозначающие типы, перечисляются в фигурных скобках и могут иметь любые имена. После знака `=` после имени типа эти переменные должны быть указаны в том же порядке в угловых скобках.

### Зависимые типы
Зависимые типы - это типы, которые зависят от переданных *значений*.

Проще говоря, generic-типы (вроде `vector<int>`) можно представлять как функции, которые принимают *тип* и возвращают тип, а зависимые (dependant) типы - как функции, которые принимают *значение* и возвращают тип.

Поддержка зависимых типов в BS очень ограниченная и делится на 2 вида: **пределы** и **nat-ограничения**. Начнем со вторых.

Они нужны, чтобы решить такую задачу: предположим, у нас есть тип `bit`, который хранит 1 бит информации. Нужно определить тип `Byte`.

Можно поступить так:
```
byte v0: bit, v1: bit, v2: bit, v3: bit, v4: bit, v5: bit, v6: bit, v7: bit = Byte;
```

Не очень приятно. А если бы нужно было хранить большее количество значений? Например, нам потребовалась структура, которая хранит в себе ровно 100 объектов типа `T`.
Для этого используются **nat-ограничения** - в комбинатор добавляется специальный параметр, который принимает натуральное число. Синтаксис такой (в этом примере объявим тип для хранения списка int известной размерности):
```
tnil = Tuple[0];
tcons [n: #] head: int, tail: Tuple[n] = Tuple[next(n)];
```

В квадратных скобках перечисляются значения комбинатора, от которых зависит тип. Они выглядят также, как и обычные параметры.

> [!NOTE]
> Если вас смущает тип `#` для параметра - это nat (натуральное число). Этот тип занимает 32 бита и должен восприниматься как `unsigned int32`. В настоящий момент все зависимые параметры должны иметь тип `#`.

Здесь мы объявили 2 конструктора для коллекции:
- конструктор пустой коллекции, который ни от чего не зависит
- конструктор непустой коллекции размерности `next(n) = n + 1`, который определяется как первый элемент этой коллекции и остаток коллекции, хранящийся в коллекции размерности на единицу меньше текущей (то есть `n`).

Этот пример более подробно разобран [в разделе про генераторы](./generators.md).

С использованием зависимых типов задачу выше можно решить сильно красивее:
```
anil {t: type} = Array<t>[0];
acons [n: #] {t: type} head: t, tail: Array<t>[n] = Array<t>[next(n)];

byte value: Array<bit>[8] = Byte;
```

Про еще один вид зависимых типов, пределы, можно почитать [тут](./generators.md).

## Методы
Название метода выглядит так:
```
(<namespace>.)? <method_name>
```

- **`<namespace>`** - опциональная часть. Например, пространство имен `messages` у метода `messages.send`. Пространства могут быть вложенными.
- **`<method name>`** - обязательная часть. Имя метода. Например, в методе `auth.phone.verify` название метода - `verify`.


# Формат схемы
Схема выглядит примерно таким образом:
```
---types---
permission bitmask: int = Permission;
user id: int, first_name: str, last_name: str | null = User;
service_user id: int, special_permissions: vector<Permission> = User;

---methods---
users.getUserById id: int = User | null;
```

Комбинаторы в блоке `types` описывают конструкторы типов. Типы могут иметь несколько конструкторов, то есть объекты таких типов могут быть объявлены с разным набором параметров.

Комбинаторы в блоке `methods` описывают RPC-методы.

Все комбинаторы должны находиться или в блоке `types`, или в блоке `methods`, при этом допускается как пропуск одного из этих блоков, так и повторное использование (например, сначала идут типы для авторизации, потом методы для авторизации, потом снова типы для сообщений, потом методы для сообщений и так далее).

## Полный синтаксис схемы
### Синтаксис комбинаторов-конструкторов
```
<combinator_name> <generics>? <dependencies>? <args>? = (<namespace>::)? <type_name> <generics>? <dependencies>?;
```

- **`<combinator_name>`** - имя комбинатора
- **`<generics>`** - (опционально) - зависимые типы для generic-типов в угловых скобках
- **`<dependencies>`** - (опционально) - зависимые значения для dependant-типов в квадратных скобках
- **`<args>?`** - (опционально) - аргументы в формате `argName: argType` через запятую
- **`<namespace>`** - (опционально) - пространство имен для типа
- **`<type_name>`** - имя типа (стоит писать с большой буквы)


### Синтаксис комбинаторов-методов
```
(<namespace>.)? <method_name> <args>? = <type>;
```

- **`<namespace>`** - (опционально) - пространство имен для метода
- **`<method_name>`** - имя метода (стоит писать с маленькой буквы)
- **`<args>?`** - (опционально) - аргументы в формате `argName: argType` через запятую
- **`<type>`** - возвращаемое значение

### Примеры
```
---types---
// Base examples
user id: int, name: string = User; // fully-defined form is `User.user`
bot id: int, owner: User.user = User; // fully-defined form is `User.bot`

// Namespaces
user id: int, name: string, is_premium: bool = external.Telegram::User; // another `User` type, but in the other namespace
user id: int, name: string = external.VK::User; // wait... another user?!

// Dimensions: let's create a 3x5 matrix!
anil {T} = Array<T>[0];
acons {T} [n: #] head: T, tail: Array<T>[n] = Array<T>[next(n)];

matrix_3x5 value: Array<Array<int>[3]>[5] = Matrix_3x5;

---methods---
users.getByIds ids: vector<int> = vector<User>;
messages.getChatMembers id: int = vector<User> | null;
```

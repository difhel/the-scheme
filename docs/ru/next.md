# Документация BS

> **Внимание!**
> Вы смотрите документацию к НЕСТАБИЛЬНОЙ ВЕРСИИ Layer Next.

# Устройство базовых типов
## Числовые типы
- `bool` - (0 - false, 1 - true). Занимает 1 бит. Все bool-значения передаются ранее всех остальных значений подряд.
- `char` или `int8` - 8-битное число
- `short` или `int16` - 16-битное число
- `int` или `int32` - 32-битное целое число
- `int64` - 64-битное целое число
- `int128` - 128-битное специальное число
- `float` - 32-битное число с плавающей точкой (одинарной точности)
- `double` - 64-битное число с плавающей точкой (двойной точности)

Целочисленные типы (`int8`, `int16`, `int32`, `int64`, `int128`) передаются в виде [дополнительного кода](hhttps://en.wikipedia.org/wiki/Two%27s_complement) до 2.

Типы чисел с плавающей точкой передаются в виде экспоненциальной записи по спецификации [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754).

## Специальные типы
- `null`. Кодируется специальным образом:
    - если тип параметра или возвращаемого значения кобминатора не может быть `null` (например, `int` или `int | vector<int>`), `null` не влияет на схему кодирования.
    - если тип параметра или возвращаемого значения может быть `null`, перед всеми остальными параметрами передаются флаги nullable-типов.

Рассмотрим допустимые значения, которые возвращает следующий метод:
```
users.getUserById id: int = User | null;
```
- `0 <alignment>` - метод вернул `null`
- `1 ...` - метод вернул не `null`, далее идет описание объекта типа `User`.

## Контейнерные типы
- `vector<T>` - вектор элементов типа `T`
- `string` - `vector<char>`

### vector<T>
В начале передается `int length` - длина вектора. Далее парсер считывает `length` раз объект типа `T`.

# Десериализация и сериализация
Формат, в котором передается весь запрос от одной стороне другой выглядит в общем виде так:

```
<4 байта на CRC32 хеш конструктора типа или метода> <bool-параметры> <флаги nullable-параметров> <кастомные флаги> <value1> <value2> ... <alignment>
```
Разберем, что означает каждый из элементов.
- **CRC32 хеш конструктора.** Хеш конструктора типа или метода, по которому парсер узнает, в каком формате представлены дальнейшие данные.
- **Bool-параметры.** Если в комбинаторе есть $n$ bool-параметров (например, `test a: int, b: bool, c: string, d: bool = Test;`), в следующих $n$ битах будут указаны значения этих параметров (например, при $a=179$, $b=true$, $c="hello"$ и $d=false$) в bool-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Вместе с остальными параметрами они повторно не передаются.
- **Флаги nullable-параметров.** Если в комбинаторе есть $n$ nullable-параметров (например, `test a: int | null, b: int, c: string | null, d: bool = Test;`), в следующих $n$ битах будет указано, имеет ли $i$-ый параметр значение null (например, при $a=null$, $b=42$, $c="hello"$ и $d=false$) в nullable-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Параметры, значения которых равны null, вместе с остальными параметрами повторно не передаются, а параметры, не являющиеся null, передаются в обычном порядке (например, если был параметр $test = T | null$, и в флагах указано, что он не null, парсеру потребуется считать значение типа $T$).
- **Кастомные флаги.** По аналогии с двумя типами флагов выше, вы можете определить кастомные флаги, на основе которых будет производиться #todo

---

Рассмотрим такой пример:
```
---types---
user id: int, user: User = ChatMember;
bot id: int, bot: Bot = ChatMember;

---methods---
messages.getChatMembers chat_id: int = vector<ChatMember> | null;
```

Представим, что метод возвращает участников чата по его идентификатору или `null`, если чата с таким `id` не существует. Также есть тип `ChatMember` с 2 конструкторами - для пользователя (человека) и бота (будем считать, что `User` и `Bot` - 2 разных типа).

Рассмотрим варианты ответа сервера на такой запрос:
- Чата не существует. Метод должен вернуть `null`. Как написано в описании типа `null`, будет возвращен такой результат из одного байта: `0`.
- Чат существует. В начале ответа сервер вернет данные о том, что ответ не `null`, и нужно дальше его парсить: `1`. Так как, помимо `null`, метод может вернуть только один тип (`vector<ChatMember>`), не нужно указывать его хеш, поскольку парсер уже знает, какой тип ожидается и может сразу начать читать вектор объектов типа `ChatMember`. Для начала должна быть прочитана длина этого вектора: `0x2` - означает, что вектор содержит 2 элемента. Дальше нужно 2 раза прочитать `ChatMember`, но у него есть 2 конструктора. Чтобы понять, какой именно из них нужно вызывать при десериализации, должен быть указан хеш от сигнатуры конструктора, по которому определяется нужный комбинатор и конструируется тип. В отличие от случая выше, когда было заранее известно, что тип - не `null`, а определяется однозначно как `vector<ChatMember>`, здесь неясно, какой из 2 типов (`ChatMember.user` или `ChatMember.bot`) должен вызываться. В качестве хеша конструктора используется CRC32 от нормализованной строки с описанием комбинатора:
```
CRC32("user id: int, user: User = ChatMember") = 0x15993ea9
CRC32("bot id: int, bot: Bot = ChatMember") = 0x69b35687
```
Для примера представим, что весь результат выполнения функции выглядит так (в виде JSON):
```json
[
    {
        "_": "ChatMember.user",
        "id": 1,
        "user": {
            "_": "User", // дальше поля, описывающие тип User
        }
    },
    {
        "_": "ChatMember.bot",
        "id": 2,
        "bot": {
            "_": "Bot", // дальше поля, описывающие тип Bot
        }
    }
]
```

В серилиазованном виде этот результат будет выглядеть примерно так:
```
0x1 0x2 0x15993ea9 0x1 <тип User> 0x69b35687 0x2 <тип Bot>
```

После рассмотрения примера опишем принципы сериализации/десериализации более строго.
- Для типа с единственным конструктором достаточно сразу указать значение подставляемого параметра. Не нужно и **нельзя** указывать хеш сигнатуры конструктора, если вызываемый конструктор известен до старта десериализации значения параметра.
- Для типа с несколькими конструкторами или опционального типа (`type_1 | type_2 | type_3`) перед указанием значения параметра должен быть указан CRC32-хеш сигнатуры конструктора типа, объект которого указывается далее. Исключение: если это опциональный тип, состоящий из одного не-`null` типа и `null`, указывать хеш не нужно, поскольку тип конструктора определяется `null`-битом (если тип `null`, то `null`-бит равен 0 и значение не указывается; если `null`-бит не 0, то тип для десериализации установлен однозначно; если у этого типа единственный конструктор - указывать хеш не требуется, если же тип полиморфный - нужно указать хеш (см. предыдущий пункт)).


# Формат схемы
Схема выглядит примерно таким образом:
```
---types---
permission bitmask: int = Permission;
user id: int, first_name: str, last_name: str | null = User;
service_user id: int, special_permissions: vector<Permission> = User;

---methods---
users.getUserById id: int = User | null;
```

Комбинаторы в блоке `types` описывают конструкторы типов. Типы могут иметь несколько конструкторов (такие типы называются полиморфными), то есть объекты таких типов могут быть объявлены с разным набором параметров. По сути, сигнатуры конструкторов даже могут быть одинаковыми, потому что при реализации конструктора используется его уникальное имя (в примере выше, для типа `User` есть 2 конструктора с уникальными именами - `User.user` и `User.service_user`). При десериализации конструктор, который будет вызван, определяется CRC32 от его сигнатуры.

## Синтаксис комбинаторов
Для комбинаторов в блоке `types`:
```
subtype_name param_1: type_1, param_2: type_2 = TypeName;
```
Здесь:
- `subtype_name` - имя конструктора типа `TypeName` (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `ChatMember.user`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `TypeName` - название определяемого типа


Для комбинаторов в блоке `methods`:
```
rpc_function_name param_1: type_1, param_2: type_2 = ResultType;
```

Здесь:
- `rpc_function_name` - название функции (метода) (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `messages.getChatMembers`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `ResultType` - тип возвращаемого значения

# Документация BS

> **Внимание!**
> Вы смотрите документацию к НЕСТАБИЛЬНОЙ ВЕРСИИ Layer Next.

# Устройство базовых типов
## Числовые типы
- `bool` - (0 - false, 1 - true). Занимает 1 бит. Все bool-значения передаются ранее всех остальных значений подряд.
- `char` или `int8` - 8-битное число
- `short` или `int16` - 16-битное число
- `int` или `int32` - 32-битное целое число
- `int64` - 64-битное целое число
- `int128` - 128-битное специальное число
- `float` - 32-битное число с плавающей точкой (одинарной точности)
- `double` - 64-битное число с плавающей точкой (двойной точности)

Целочисленные типы (`int8`, `int16`, `int32`, `int64`, `int128`) передаются в виде [дополнительного кода](https://en.wikipedia.org/wiki/Two%27s_complement) до 2.

Типы чисел с плавающей точкой передаются в виде экспоненциальной записи по спецификации [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754).

## Специальные типы
- `null`. Кодируется специальным образом:
    - если тип параметра или возвращаемого значения кобминатора не может быть `null` (например, `int` или `int | vector<int>`), `null` не влияет на схему кодирования.
    - если тип параметра или возвращаемого значения может быть `null`, перед всеми остальными параметрами передаются флаги nullable-типов.

Рассмотрим допустимые значения, которые возвращает следующий метод:
```
users.getUserById id: int = User | null;
```
- `0 <alignment>` - метод вернул `null`
- `1 ...` - метод вернул не `null`, далее идет описание объекта типа `User`.

## Контейнерные типы
- `vector<T>` - вектор элементов типа `T`
- `string` - `vector<char>`

### vector<T>
В начале передается `int length` - длина вектора. Далее парсер считывает `length` раз объект типа `T`.

# Десериализация и сериализация
Формат, в котором передается весь запрос от одной стороне другой выглядит в общем виде так:

```
<4 байта на CRC32 хеш конструктора типа или метода> <bool-параметры> <флаги nullable-параметров> <value1> <value2> ... <alignment>
```
Разберем, что означает каждый из элементов.
- **CRC32 хеш конструктора.** Хеш конструктора типа или метода, по которому парсер узнает, в каком формате представлены дальнейшие данные.
- **Bool-параметры.** Если в комбинаторе есть $n$ bool-параметров (например, `test a: int, b: bool, c: string, d: bool = Test;`), в следующих $n$ битах будут указаны значения этих параметров (например, при $a=179$, $b=true$, $c="hello"$ и $d=false$) в bool-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Вместе с остальными параметрами они повторно не передаются.
- **Флаги nullable-параметров.** Если в комбинаторе есть $n$ nullable-параметров (например, `test a: int | null, b: int, c: string | null, d: bool = Test;`), в следующих $n$ битах будет указано, имеет ли $i$-ый параметр значение null (например, при $a=null$, $b=42$, $c="hello"$ и $d=false$) в nullable-флагах будет 0b10. Значения идут в том же порядке, что и при объявлении параметров в схеме. Параметры, значения которых равны null, вместе с остальными параметрами повторно не передаются, а параметры, не являющиеся null, передаются в обычном порядке (например, если был параметр $test = T | null$, и в флагах указано, что он не null, парсеру потребуется считать значение типа $T$).
- **`<alignment>`.** Дополнение последнего байта в запросе неустановленными битами, чтобы размер запроса занимал целочисленное количество байт.

**В случае ответа на запрос, схема точно такая же, но хеш не передается**. Это попросту ненужно: хеш вызываемого метода известен клиенту, так как ему известно, ответом на какой запрос данный ответ является. Тип ответа тоже не указывается, так как он известен на этапе десериализации.

---

Рассмотрим такой пример:
```
---types---
user id: int, user: User = ChatMember;
bot id: int, bot: Bot = ChatMember;

---methods---
messages.getChatMembers chat_id: int = vector<ChatMember> | null;
```

Представим, что метод возвращает участников чата по его идентификатору или `null`, если чата с таким `id` не существует. Также есть тип `ChatMember` с 2 конструкторами - для пользователя (человека) и бота (будем считать, что `User` и `Bot` - 2 разных типа).

Рассмотрим варианты ответа сервера на такой запрос:
- Чата не существует. Метод должен вернуть `null`. Как написано в описании типа `null`, будет возвращен такой результат из одного байта: `0`.
- Чат существует. В начале ответа сервер вернет данные о том, что ответ не `null`, и нужно дальше его парсить: `1`. Так как, помимо `null`, метод может вернуть только один тип (`vector<ChatMember>`), не нужно указывать его хеш, поскольку парсер уже знает, какой тип ожидается и может сразу начать читать вектор объектов типа `ChatMember`. Для начала должна быть прочитана длина этого вектора: `0x2` - означает, что вектор содержит 2 элемента. Дальше нужно 2 раза прочитать `ChatMember`, но у него есть 2 конструктора. Чтобы понять, какой именно из них нужно вызывать при десериализации, должен быть указан хеш от сигнатуры конструктора, по которому определяется нужный комбинатор и конструируется тип. В отличие от случая выше, когда было заранее известно, что тип - не `null`, а определяется однозначно как `vector<ChatMember>`, здесь неясно, какой из 2 типов (`ChatMember.user` или `ChatMember.bot`) должен вызываться. В качестве хеша конструктора используется CRC32 от нормализованной строки с описанием комбинатора:
```
CRC32("user id: int, user: User = ChatMember") = 0x15993ea9
CRC32("bot id: int, bot: Bot = ChatMember") = 0x69b35687
```
Для примера представим, что весь результат выполнения функции выглядит так (в виде JSON):
```json
[
    {
        "_": "ChatMember.user",
        "id": 1,
        "user": {
            "_": "User", // дальше поля, описывающие тип User
        }
    },
    {
        "_": "ChatMember.bot",
        "id": 2,
        "bot": {
            "_": "Bot", // дальше поля, описывающие тип Bot
        }
    }
]
```

В серилиазованном виде этот результат будет выглядеть примерно так:
```
0x1 0x2 0x15993ea9 0x1 <тип User> 0x69b35687 0x2 <тип Bot>
```

После рассмотрения примера опишем принципы сериализации/десериализации более строго.
- Для типа с единственным конструктором достаточно сразу указать значение подставляемого параметра. Не нужно и **нельзя** указывать хеш сигнатуры конструктора, если вызываемый конструктор известен до старта десериализации значения параметра.
- Для типа с несколькими конструкторами или опционального типа (`type_1 | type_2 | type_3`) перед указанием значения параметра должен быть указан CRC32-хеш сигнатуры конструктора типа, объект которого указывается далее. Исключение: если это опциональный тип, состоящий из одного не-`null` типа и `null`, указывать хеш не нужно, поскольку тип конструктора определяется `null`-битом (если тип `null`, то `null`-бит равен 0 и значение не указывается; если `null`-бит не 0, то тип для десериализации установлен однозначно; если у этого типа единственный конструктор - указывать хеш не требуется, если же тип полиморфный - нужно указать хеш (см. предыдущий пункт)).

# Формат схемы
## Типы
### Обзор
Типы используются в параметрах функции или другого типа, а также в возвращаемом значении функции. Они могут быть описаны двумя способами:
1. **Only type name.** Например, `User`. Если у типа есть только один конструктор, он и будет использоваться при работе с данными, иначе потребуется указать CRC32 хеш конструктора, который используется в данном случае.
2. **Fully-defined type.** Например, `User.bot`. В такой записи указывается сам тип и вызываемый конструктор, что позволяет однозначно установить, в каком формате будут передаваться данные, из-за чего указывать хеш конструктора не нужно.

В общем виде тип выглядит так:
```
(<namespace>::)? <type name> (.<constructor name>)>?
```

Здесь:
- **`namespace`** - опциональная часть - у типа может быть свое пространство имен для избежания конфликтов (например, вы пишите сервис, который взаимодействует с сторонним API; и у вашего API, и у стороннего есть тип `User` - в таком случае для удобства можно разделить типы на namespaces - например, `internal::User` и `external::User`). Вы также можете использовать вложенные пространства имен, разделяя названия точками - например, `external.telegram::User`.
- **`<type name>`** - обязательная часть - название типа. По очевидным причинам не может содержать точки.
-  **`<constructor name>`** - опциональная часть - четкое указание конструктора (для fully-defined типов).

Еще немного дополнительных фактов про пространства имен:
- все встроенные типы находятся в пространстве имен под названием `std`, из-за чего `std::int` и `int` - это одно и то же. Это сделано для удобства, не стоит использовать префикс `std::` перед указанием встроенного типа.
- все определяемые программистом типы помещаются в пространство `default`, из-за чего `default::User` и `User` - это одно и то же. Это сделано для удобства, не стоит использовать префикс `default::` перед указанием кастомного типа без указанного пространства имен.

### Зависимые типы
Зависимые типы - это типы, которые зависят от значения.

Проще говоря, generic-типы (вроде `vector<int>`) можно представлять как функции, которые принимают тип и возвращают тип, а зависимые (dependant) типы - как функции, которые принимают значение и тоже возвращают тип.

Поддержка зависимых типов в BS очень ограниченная и делится на 2 вида: **пределы** и **nat-ограничения**. Начнем со вторых.

Они нужны, чтобы решить такую задачу: предположим, у нас есть тип `bit`, который хранит 1 бит информации. Нужно определить тип `Byte`.

Можно поступить так:
```
byte v0: bit, v1: bit, v2: bit, v3: bit, v4: bit, v5: bit, v6: bit, v7: bit = Byte;
```

Не очень приятно. А если бы нужно было хранить большее количество значений?
Для этого используются **nat-ограничения** - в комбинатор добавляется специальный параметр, который принимает натуральное число. Синтаксис такой (в этом примере объявим тип для хранения списка int известной размерности):
```
tnil = Tuple[0];
tcons [n: #] head: int, tail: Tuple[n] = Tuple[next(n)];
```

С таким определением, `Tuple[3] = value0 + Tuple[2] = value0 + value1 + Tuple[1] = value0 + value1 + value2 + Tuple[0] = value0 + value1 + value2`.

Смотрите подробнее про `next(n)` [тут](./generators.md).

С использованием зависимых типов задачу выше можно решить сильно красивее:
```
anil {t: type} = Array<t>[0];
acons [n: #] {t: type} head: t, tail: Array<t>[n] = Array<t>[next(n)];

byte value: Array<bit>[8] = Byte;
```

## Методы
Название метода выглядит так:
```
(<namespace>.)? <method_name>
```

---

# DEPRECATED INFO BELOW
# Формат схемы
Схема выглядит примерно таким образом:
```
---types---
permission bitmask: int = Permission;
user id: int, first_name: str, last_name: str | null = User;
service_user id: int, special_permissions: vector<Permission> = User;

---methods---
users.getUserById id: int = User | null;
```

Комбинаторы в блоке `types` описывают конструкторы типов. Типы могут иметь несколько конструкторов (такие типы называются полиморфными), то есть объекты таких типов могут быть объявлены с разным набором параметров. По сути, сигнатуры конструкторов даже могут быть одинаковыми, потому что при реализации конструктора используется его уникальное имя (в примере выше, для типа `User` есть 2 конструктора с уникальными именами - `User.user` и `User.service_user`). При десериализации конструктор, который будет вызван, определяется CRC32 от его сигнатуры.

## Синтаксис комбинаторов
Для комбинаторов в блоке `types`:
```
subtype_name param_1: type_1, param_2: type_2 = TypeName;
```
Здесь:
- `subtype_name` - имя конструктора типа `TypeName` (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `ChatMember.user`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `TypeName` - название определяемого типа


Для комбинаторов в блоке `methods`:
```
rpc_function_name param_1: type_1, param_2: type_2 = ResultType;
```

Здесь:
- `rpc_function_name` - название функции (метода) (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `messages.getChatMembers`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `ResultType` - тип возвращаемого значения

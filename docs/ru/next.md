# Документация BS

> **Внимание!**
> Вы смотрите документацию к НЕСТАБИЛЬНОЙ ВЕРСИИ Layer Next.

# Устройство базовых типов
## Числовые типы
- `bool` - alias для `char` (0x0 - false, 0x1 - true). Занимает 1 байт из-за выравнивания памяти и того факта, что данные десериализуются побайтово.
- `char` или `int8` - 8-битное число
- `short` или `int16` - 16-битное число
- `int` или `int32` - 32-битное целое число (дополнительный код (до 2))
- `double` - 64-битное число (экспоненциальная запись)

Каждый числовой тип, кроме `bool`, по умолчанию является `signed`. Использование `unsigned` типов реализуется через указание ключевого слова `unsigned` перед названием типа в комбинаторе и изменяет диапазон допустимых значений с $[-2^{n-1}, 2^{n-1}-1]$ для n-битных `signed` типов на $[0, 2^{n}-1]$ для `unsigned`.

Отдельно стоит уточнить, что `unsigned` не может быть применен к `bool` из идейных соображений и к `double` (стандарт чисел с плавающей точкой [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision#Formats) не поддерживает беззнаковые числа).

## Специальные типы
- `null`. Кодируется специальным образом:
    - если тип параметра или возвращаемого значения кобминатора не может быть `null` (например, `int` или `int | vector<int>`), `null` не влияет на схему кодирования.
    - если тип параметра или возвращаемого значения `null` или может быть `null` (например, `null` или `User | null`), в закодированном виде сначала идет байт `0x1`, если значение имеет отличный от `null` тип, и байт `0x0` в противном случае.

Рассмотрим допустимые значения, которые возвращает следующий метод:
```
users.getUserById id: int = User | null;
```
- `0x0` - метод вернул `null`
- `0x1 ...` - метод вернул не `null`, далее идет описание объекта типа `User`.

## Контейнерные типы
- `vector<T>` - вектор элементов типа `T`
- `string` - `vector<char>`

### vector<T>
В начале передается `unsigned int length` - длина вектора. Далее парсер считывает `length` раз объект типа `T`.

# Десериализация и сериализация
Расмотрим такой пример:
```
---types---
user id: int, user: User = ChatMember;
bot id: int, bot: Bot = ChatMember;

---methods---
messages.getChatMembers chat_id: int = vector<ChatMember> | null;
```

Представим, что метод возвращает участников чата по его идентификатору или `null`, если чата с таким `id` не существует. Также есть тип `ChatMember` с 2 конструкторами - для пользователя (человека) и бота (будем считать, что `User` и `Bot` - 2 разных типа).

Рассмотрим варианты ответа сервера на такой запрос:
- Чата не существует. Метод должен вернуть `null`. Как написано в описании типа `null`, будет возвращен такой результат из одного байта: `0`.
- Чат существует. В начале ответа сервер вернет данные о том, что ответ не `null`, и нужно дальше его парсить: `1`. Так как, помимо `null`, метод может вернуть только один тип (`vector<ChatMember>`), не нужно указывать его хеш, поскольку парсер уже знает, какой тип ожидается и может сразу начать читать вектор объектов типа `ChatMember`. Для начала должна быть прочитана длина этого вектора: `0x2` - означает, что вектор содержит 2 элемента. Дальше нужно 2 раза прочитать `ChatMember`, но у него есть 2 конструктора. Чтобы понять, какой именно из них нужно вызывать при десериализации, должен быть указан хеш от сигнатуры конструктора, по которому определяется нужный комбинатор и конструируется тип. В отличие от случая выше, когда было заранее известно, что тип - не `null`, а определяется однозначно как `vector<ChatMember>`, здесь неясно, какой из 2 типов (`ChatMember.user` или `ChatMember.bot`) должен вызываться. В качестве хеша конструктора используется CRC32 от нормализованной строки с описанием комбинатора:
```
CRC32("user id: int, user: User = ChatMember") = 0x15993ea9
CRC32("bot id: int, bot: Bot = ChatMember") = 0x69b35687
```
Для примера представим, что весь результат выполнения функции выглядит так (в виде JSON):
```json
[
    {
        "_": "ChatMember.user",
        "id": 1,
        "user": {
            "_": "User", // дальше поля, описывающие тип User
        }
    },
    {
        "_": "ChatMember.bot",
        "id": 2,
        "bot": {
            "_": "Bot", // дальше поля, описывающие тип Bot
        }
    }
]
```

В серилиазованном виде этот результат будет выглядеть примерно так:
```
0x1 0x2 0x15993ea9 0x1 <тип User> 0x69b35687 0x2 <тип Bot>
```

После рассмотрения примера опишем принципы сериализации/десериализации более строго.
- Для типа с единственным конструктором достаточно сразу указать значение подставляемого параметра. Не нужно и **нельзя** указывать хеш сигнатуры конструктора, если вызываемый конструктор известен до старта десериализации значения параметра.
- Для типа с несколькими конструкторами или опционального типа (`type_1 | type_2 | type_3`) перед указанием значения параметра должен быть указан CRC32-хеш сигнатуры конструктора типа, объект которого указывается далее. Исключение: если это опциональный тип, состоящий из одного не-`null` типа и `null`, указывать хеш не нужно, поскольку тип конструктора определяется `null`-битом (если тип `null`, то `null`-бит равен 0 и значение не указывается; если `null`-бит не 0, то тип для десериализации установлен однозначно; если у этого типа единственный конструктор - указывать хеш не требуется, если же тип полиморфный - нужно указать хеш (см. предыдущий пункт)).


# Формат схемы
Схема выглядит примерно таким образом:
```
---types---
permission bitmask: int = Permission;
user id: int, first_name: str, last_name: str | null = User;
service_user id: int, special_permissions: vector<Permission> = User;

---methods---
users.getUserById id: int = User | null;
```

Комбинаторы в блоке `types` описывают конструкторы типов. Типы могут иметь несколько конструкторов (такие типы называются полиморфными), то есть объекты таких типов могут быть объявлены с разным набором параметров. По сути, сигнатуры конструкторов даже могут быть одинаковыми, потому что при реализации конструктора используется его уникальное имя (в примере выше, для типа `User` есть 2 конструктора с уникальными именами - `User.user` и `User.service_user`). При десериализации конструктор, который будет вызван, определяется CRC32 от его сигнатуры.

## Синтаксис комбинаторов
Для комбинаторов в блоке `types`:
```
subtype_name param_1: type_1, param_2: type_2 = TypeName;
```
Здесь:
- `subtype_name` - имя конструктора типа `TypeName` (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `ChatMember.user`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `TypeName` - название определяемого типа


Для комбинаторов в блоке `methods`:
```
rpc_function_name param_1: type_1, param_2: type_2 = ResultType;
```

Здесь:
- `rpc_function_name` - название функции (метода) (в примере выше в разделе [Десериализация и сериализация](#десериализация-и-сериализация) это `messages.getChatMembers`)
- параметры описываются через запятую с указанием типа (синтаксис похож на синтаксис указания типов в TypeScript и Python). Значения по умолчанию не допускаются
- `ResultType` - тип возвращаемого значения
